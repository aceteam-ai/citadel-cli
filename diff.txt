diff --git a/citadel.yaml b/citadel.yaml
index e9257ab..73076fb 100644
--- a/citadel.yaml
+++ b/citadel.yaml
@@ -6,11 +6,11 @@ node:
 # NOTE: You probably only want ONE of these containers running
 # as they can be quite resource intensive.
 services:
-  - name: llamacpp
-    compose_file: ./services/llamacpp.yml
+  # - name: llamacpp
+  #   compose_file: ./services/llamacpp.yml
 
-  - name: ollama
-    compose_file: ./services/ollama.yml
+  # - name: ollama
+  #   compose_file: ./services/ollama.yml
 
   - name: vllm
     compose_file: ./services/vllm.yml
diff --git a/cmd/agent.go b/cmd/agent.go
index ba0a9e1..7b58b08 100644
--- a/cmd/agent.go
+++ b/cmd/agent.go
@@ -90,7 +90,7 @@ func getUserHomeDir() string {
 }
 
 // executeJob runs the job, captures its output, and reports the status back to Nexus.
-func executeJob(client *nexus.Client, job *nexus.Job) {
+func executeJob(client *nexus.Client, job *nexus.Job) (string, error) {
 	var output []byte
 	var err error
 	var status string
@@ -398,7 +398,12 @@ func executeJob(client *nexus.Client, job *nexus.Job) {
 
 	if err != nil {
 		status = "FAILURE"
-		output = []byte(fmt.Sprintf("Execution Error: %v\n---\n%s", err, string(output)))
+		errorMsg := fmt.Sprintf("Execution Error: %v", err)
+		// Combine the error and any command output for a full report
+		if len(output) > 0 {
+			errorMsg = fmt.Sprintf("%s\n---\n%s", errorMsg, string(output))
+		}
+		output = []byte(errorMsg)
 		fmt.Fprintf(os.Stderr, "     - [Job %s] ‚ùå Execution failed: %v\n", job.ID, err)
 	} else {
 		status = "SUCCESS"
@@ -410,9 +415,11 @@ func executeJob(client *nexus.Client, job *nexus.Job) {
 		Output: string(output),
 	}
 
-	if err := client.UpdateJobStatus(job.ID, update); err != nil {
-		fmt.Fprintf(os.Stderr, "     - [Job %s] ‚ö†Ô∏è CRITICAL: Failed to report status back to Nexus: %v\n", job.ID, err)
+	if reportErr := client.UpdateJobStatus(job.ID, update); reportErr != nil {
+		fmt.Fprintf(os.Stderr, "     - [Job %s] ‚ö†Ô∏è CRITICAL: Failed to report status back to Nexus: %v\n", job.ID, reportErr)
 	}
+	return status, err
+
 }
 
 func init() {
diff --git a/cmd/bootstrap.go b/cmd/bootstrap.go
index f23e0c5..e39196f 100644
--- a/cmd/bootstrap.go
+++ b/cmd/bootstrap.go
@@ -5,19 +5,31 @@ import (
 	"fmt"
 	"os"
 	"os/exec"
+	"path/filepath"
+	"strconv"
+	"strings"
+	"syscall"
 
+	"github.com/AlecAivazis/survey/v2"
+	"github.com/aceboss/citadel-cli/services"
 	"github.com/spf13/cobra"
+	"gopkg.in/yaml.v3"
 )
 
 var authKey string
 
-// bootstrapCmd represents the bootstrap command
+var (
+	bootstrapService  string
+	bootstrapNodeName string
+	bootstrapTest     bool
+)
+
 var bootstrapCmd = &cobra.Command{
 	Use:   "bootstrap",
 	Short: "Provisions a fresh Ubuntu server to become a Citadel Node",
-	Long: `RUN WITH SUDO. This command installs all necessary dependencies (Docker,
-NVIDIA drivers, Tailscale) and then brings the node online using the provided
-authkey. It is idempotent and can be run multiple times.`,
+	Long: `RUN WITH SUDO. This command installs all necessary dependencies, generates a
+configuration based on your input, and brings the node online. It can be run
+interactively or with flags for automation.`,
 	Run: func(cmd *cobra.Command, args []string) {
 		if !isRoot() {
 			fmt.Fprintln(os.Stderr, "‚ùå Error: bootstrap command must be run with sudo.")
@@ -25,28 +37,50 @@ authkey. It is idempotent and can be run multiple times.`,
 		}
 		fmt.Println("‚úÖ Running with root privileges.")
 
+		// --- 1. Determine Configuration ---
+		selectedService, err := getSelectedService()
+		if err != nil {
+			fmt.Fprintf(os.Stderr, "‚ùå Canceled: %v\n", err)
+			os.Exit(1)
+		}
+
+		nodeName, err := getNodeName()
+		if err != nil {
+			fmt.Fprintf(os.Stderr, "‚ùå Error getting node name: %v\n", err)
+			os.Exit(1)
+		}
+
+		// --- 2. Generate Config Files ---
+		originalUser := os.Getenv("SUDO_USER")
+		if originalUser == "" {
+			fmt.Fprintln(os.Stderr, "‚ùå Could not determine the original user from $SUDO_USER.")
+			os.Exit(1)
+		}
+		configDir, err := generateCitadelConfig(originalUser, nodeName, selectedService)
+		if err != nil {
+			fmt.Fprintf(os.Stderr, "‚ùå Failed to generate configuration files: %v\n", err)
+			os.Exit(1)
+		}
+
+		// --- 3. Provision System ---
+		// (This part is the same as before)
 		provisionSteps := []struct {
 			name     string
 			checkCmd string
 			run      func() error
 		}{
-			{"Package Lists", "", updateApt}, // No check needed for apt update
+			{"Package Lists", "", updateApt},
 			{"Core Dependencies", "", installCoreDeps},
 			{"Docker", "docker", installDocker},
-			{"Docker Service", "", startDockerDaemon},
 			{"System User", "", setupUser},
 			{"NVIDIA Container Toolkit", "nvidia-ctk", installNvidiaToolkit},
 			{"Tailscale", "tailscale", installTailscale},
-			{"Tailscale Service", "", startTailscaleDaemon},
-			// The daemon-ready check is now handled by 'citadel up'
 		}
-
 		fmt.Println("--- üöÄ Starting Node Provisioning ---")
 		for _, step := range provisionSteps {
 			fmt.Printf("   - Processing step: %s\n", step.name)
-
 			if step.checkCmd != "" && isCommandAvailable(step.checkCmd) {
-				fmt.Printf("     ‚úÖ Prerequisite '%s' is already installed. Skipping installation.\n", step.checkCmd)
+				fmt.Printf("     ‚úÖ Prerequisite '%s' is already installed. Skipping.\n", step.checkCmd)
 			} else {
 				if err := step.run(); err != nil {
 					if step.name == "NVIDIA Container Toolkit" {
@@ -60,32 +94,156 @@ authkey. It is idempotent and can be run multiple times.`,
 		}
 		fmt.Println("‚úÖ System provisioning complete.")
 
+		// --- 4. Hand off to 'citadel up' ---
 		fmt.Println("--- üöÄ Handing off to 'citadel up' to bring node online ---")
-		originalUser := os.Getenv("SUDO_USER")
-		if originalUser == "" {
-			fmt.Fprintln(os.Stderr, "‚ùå Could not determine the original user from $SUDO_USER.")
+		executablePath, _ := os.Executable()
+		upCommandString := fmt.Sprintf("cd %s && %s up --authkey %s", configDir, executablePath, authKey)
+		upCmd := exec.Command("sudo", "-u", originalUser, "sh", "-c", upCommandString)
+		upCmd.Stdout = os.Stdout
+		upCmd.Stderr = os.Stderr
+		if err := upCmd.Run(); err != nil {
+			fmt.Fprintf(os.Stderr, "‚ùå 'citadel up' command failed: %v\n", err)
 			os.Exit(1)
 		}
 
-		executablePath, err := os.Executable()
-		if err != nil {
-			fmt.Fprintf(os.Stderr, "‚ùå Could not find path to citadel binary: %v\n", err)
-			os.Exit(1)
+		// --- 5. Run Test if Requested ---
+		if bootstrapTest {
+			fmt.Println("\n--- üöÄ Handing off to 'citadel test' to verify node health ---")
+			testCommandString := fmt.Sprintf("cd %s && %s test --service %s", configDir, executablePath, selectedService)
+			testCmd := exec.Command("sudo", "-u", originalUser, "sh", "-c", testCommandString)
+			testCmd.Stdout = os.Stdout
+			testCmd.Stderr = os.Stderr
+			if err := testCmd.Run(); err != nil {
+				// The test command prints its own success/failure message, so we just exit.
+				os.Exit(1)
+			}
 		}
+	},
+}
 
-		// MODIFIED: Use `newgrp docker` to ensure the user's new group membership is active
-		// for the 'citadel up' command, allowing it to access the docker socket.
-		upCommandString := fmt.Sprintf("%s up --authkey %s", executablePath, authKey)
-		upCmd := exec.Command("/usr/bin/sudo", "-u", originalUser, "newgrp", "docker", "-c", upCommandString)
+func getSelectedService() (string, error) {
+	if bootstrapService != "" {
+		// Validate the service provided by flag
+		validServices := append(services.GetAvailableServices(), "none")
+		for _, s := range validServices {
+			if bootstrapService == s {
+				fmt.Printf("‚úÖ Using specified service: %s\n", bootstrapService)
+				return bootstrapService, nil
+			}
+		}
+		return "", fmt.Errorf("invalid service '%s' specified", bootstrapService)
+	}
 
-		upCmd.Stdout = os.Stdout
-		upCmd.Stderr = os.Stderr
+	// Interactive prompt
+	prompt := &survey.Select{
+		Message: "Which primary service should this node run?",
+		Options: []string{
+			"vllm (High-throughput OpenAI-compatible API)",
+			"ollama (General purpose, easy to use)",
+			"llamacpp (Versatile GGUF server)",
+			"none (Connect to network only)",
+		},
+	}
+	var selection string
+	if err := survey.AskOne(prompt, &selection); err != nil {
+		return "", err
+	}
+	// Extract the short name (e.g., "vllm" from "vllm (...)")
+	return strings.Fields(selection)[0], nil
+}
 
-		if err := upCmd.Run(); err != nil {
-			fmt.Fprintf(os.Stderr, "‚ùå 'citadel up' command failed: %v\n", err)
-			os.Exit(1)
+func getNodeName() (string, error) {
+	if bootstrapNodeName != "" {
+		fmt.Printf("‚úÖ Using specified node name: %s\n", bootstrapNodeName)
+		return bootstrapNodeName, nil
+	}
+	defaultName, err := os.Hostname()
+	if err != nil {
+		return "", err
+	}
+	prompt := &survey.Input{
+		Message: "Enter a name for this node:",
+		Default: defaultName,
+	}
+	var nodeName string
+	if err := survey.AskOne(prompt, &nodeName); err != nil {
+		return "", err
+	}
+	return nodeName, nil
+}
+
+func generateCitadelConfig(user, nodeName, serviceName string) (string, error) {
+	fmt.Println("--- üìù Generating configuration files ---")
+	homeDir := "/home/" + user
+	configDir := filepath.Join(homeDir, "citadel-node")
+	servicesDir := filepath.Join(configDir, "services")
+
+	if err := os.MkdirAll(servicesDir, 0755); err != nil {
+		return "", err
+	}
+
+	// Generate service compose files
+	for name, content := range services.ServiceMap {
+		filePath := filepath.Join(servicesDir, name+".yml")
+		if err := os.WriteFile(filePath, []byte(content), 0644); err != nil {
+			return "", err
 		}
-	},
+	}
+
+	// Generate citadel.yaml
+	manifest := CitadelManifest{
+		Node: struct {
+			Name string   `yaml:"name"`
+			Tags []string `yaml:"tags"`
+		}{
+			Name: nodeName,
+			Tags: []string{"gpu", "provisioned-by-citadel"},
+		},
+	}
+	if serviceName != "none" {
+		manifest.Services = []Service{
+			{
+				Name:        serviceName,
+				ComposeFile: filepath.Join("./services", serviceName+".yml"),
+			},
+		}
+	}
+
+	yamlData, err := yaml.Marshal(&manifest)
+	if err != nil {
+		return "", err
+	}
+
+	manifestPath := filepath.Join(configDir, "citadel.yaml")
+	if err := os.WriteFile(manifestPath, yamlData, 0644); err != nil {
+		return "", err
+	}
+
+	// IMPORTANT: Change ownership of the generated files to the original user
+	userInfo, err := exec.Command("id", "-u", user).Output()
+	if err != nil {
+		return "", err
+	}
+	uid, _ := strconv.Atoi(strings.TrimSpace(string(userInfo)))
+
+	groupInfo, err := exec.Command("id", "-g", user).Output()
+	if err != nil {
+		return "", err
+	}
+	gid, _ := strconv.Atoi(strings.TrimSpace(string(groupInfo)))
+
+	err = filepath.Walk(configDir, func(path string, info os.FileInfo, err error) error {
+		if err != nil {
+			return err
+		}
+		return syscall.Chown(path, uid, gid)
+	})
+	if err != nil {
+		return "", fmt.Errorf("failed to chown config directory: %w", err)
+	}
+
+	fmt.Printf("‚úÖ Configuration generated in %s\n", configDir)
+	return configDir, nil
 }
 
 // --- Helper Functions ---
@@ -207,4 +365,9 @@ func init() {
 	rootCmd.AddCommand(bootstrapCmd)
 	bootstrapCmd.Flags().StringVar(&authKey, "authkey", "", "The pre-authenticated key to join the network")
 	bootstrapCmd.MarkFlagRequired("authkey")
+	// New flags for automation
+	bootstrapCmd.Flags().StringVar(&bootstrapService, "service", "", "Service to configure (vllm, ollama, llamacpp, none)")
+	bootstrapCmd.Flags().StringVar(&bootstrapNodeName, "node-name", "", "Set the node name (defaults to hostname)")
+	bootstrapCmd.Flags().BoolVar(&bootstrapTest, "test", false, "Run a diagnostic test after provisioning")
+
 }
diff --git a/cmd/up.go b/cmd/up.go
index f4e5c8b..bb5aef9 100644
--- a/cmd/up.go
+++ b/cmd/up.go
@@ -26,6 +26,10 @@ type CitadelManifest struct {
 	Name     string    `yaml:"name"`
 	Tags     []string  `yaml:"tags"`
 	Services []Service `yaml:"services"`
+	Node     struct {
+		Name string   `yaml:"name"`
+		Tags []string `yaml:"tags"`
+	} `yaml:"node"`
 }
 
 // upCmd represents the up command
diff --git a/go.mod b/go.mod
index eb7018b..cc9966d 100644
--- a/go.mod
+++ b/go.mod
@@ -5,9 +5,14 @@ go 1.21.6
 require github.com/spf13/cobra v1.10.1
 
 require (
+	github.com/AlecAivazis/survey/v2 v2.3.7 // indirect
 	github.com/go-ole/go-ole v1.2.6 // indirect
 	github.com/inconshreveable/mousetrap v1.1.0 // indirect
+	github.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51 // indirect
 	github.com/lufia/plan9stats v0.0.0-20211012122336-39d0f177ccd0 // indirect
+	github.com/mattn/go-colorable v0.1.2 // indirect
+	github.com/mattn/go-isatty v0.0.8 // indirect
+	github.com/mgutz/ansi v0.0.0-20170206155736-9520e82c474b // indirect
 	github.com/power-devops/perfstat v0.0.0-20210106213030-5aafc221ea8c // indirect
 	github.com/shirou/gopsutil/v3 v3.24.5 // indirect
 	github.com/shoenig/go-m1cpu v0.1.6 // indirect
@@ -16,5 +21,7 @@ require (
 	github.com/tklauser/numcpus v0.6.1 // indirect
 	github.com/yusufpapurcu/wmi v1.2.4 // indirect
 	golang.org/x/sys v0.20.0 // indirect
+	golang.org/x/term v0.0.0-20210927222741-03fcf44c2211 // indirect
+	golang.org/x/text v0.4.0 // indirect
 	gopkg.in/yaml.v3 v3.0.1 // indirect
 )
diff --git a/go.sum b/go.sum
index 597f67f..4eda956 100644
--- a/go.sum
+++ b/go.sum
@@ -1,11 +1,27 @@
+github.com/AlecAivazis/survey/v2 v2.3.7 h1:6I/u8FvytdGsgonrYsVn2t8t4QiRnh6QSTqkkhIiSjQ=
+github.com/AlecAivazis/survey/v2 v2.3.7/go.mod h1:xUTIdE4KCOIjsBAE1JYsUPoCqYdZ1reCfTwbto0Fduo=
+github.com/Netflix/go-expect v0.0.0-20220104043353-73e0943537d2/go.mod h1:HBCaDeC1lPdgDeDbhX8XFpy1jqjK0IBG8W5K+xYqA0w=
 github.com/cpuguy83/go-md2man/v2 v2.0.6/go.mod h1:oOW0eioCTA6cOiMLiUPZOpcVxMig6NIQQ7OS05n1F4g=
+github.com/creack/pty v1.1.17/go.mod h1:MOBLtS5ELjhRRrroQr9kyvTxUAFNvYEK993ew/Vr4O4=
+github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
+github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
 github.com/go-ole/go-ole v1.2.6 h1:/Fpf6oFPoeFik9ty7siob0G6Ke8QvQEuVcuChpwXzpY=
 github.com/go-ole/go-ole v1.2.6/go.mod h1:pprOEPIfldk/42T2oK7lQ4v4JSDwmV0As9GaiUsvbm0=
 github.com/google/go-cmp v0.5.6/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
+github.com/hinshun/vt10x v0.0.0-20220119200601-820417d04eec/go.mod h1:Q48J4R4DvxnHolD5P8pOtXigYlRuPLGl6moFx3ulM68=
 github.com/inconshreveable/mousetrap v1.1.0 h1:wN+x4NVGpMsO7ErUn/mUI3vEoE6Jt13X2s0bqwp9tc8=
 github.com/inconshreveable/mousetrap v1.1.0/go.mod h1:vpF70FUmC8bwa3OWnCshd2FqLfsEA9PFc4w1p2J65bw=
+github.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51 h1:Z9n2FFNUXsshfwJMBgNA0RU6/i7WVaAegv3PtuIHPMs=
+github.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51/go.mod h1:CzGEWj7cYgsdH8dAjBGEr58BoE7ScuLd+fwFZ44+/x8=
 github.com/lufia/plan9stats v0.0.0-20211012122336-39d0f177ccd0 h1:6E+4a0GO5zZEnZ81pIr0yLvtUWk2if982qA3F3QD6H4=
 github.com/lufia/plan9stats v0.0.0-20211012122336-39d0f177ccd0/go.mod h1:zJYVVT2jmtg6P3p1VtQj7WsuWi/y4VnjVBn7F8KPB3I=
+github.com/mattn/go-colorable v0.1.2 h1:/bC9yWikZXAL9uJdulbSfyVNIR3n3trXl+v8+1sx8mU=
+github.com/mattn/go-colorable v0.1.2/go.mod h1:U0ppj6V5qS13XJ6of8GYAs25YV2eR4EVcfRqFIhoBtE=
+github.com/mattn/go-isatty v0.0.8 h1:HLtExJ+uU2HOZ+wI0Tt5DtUDrx8yhUqDcp7fYERX4CE=
+github.com/mattn/go-isatty v0.0.8/go.mod h1:Iq45c/XA43vh69/j3iqttzPXn0bhXyGjM0Hdxcsrc5s=
+github.com/mgutz/ansi v0.0.0-20170206155736-9520e82c474b h1:j7+1HpAFS1zy5+Q4qx1fWh90gTKwiN4QCGoY9TWyyO4=
+github.com/mgutz/ansi v0.0.0-20170206155736-9520e82c474b/go.mod h1:01TrycV0kFyexm33Z7vhZRXopbI8J3TDReVlkTgMUxE=
+github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
 github.com/power-devops/perfstat v0.0.0-20210106213030-5aafc221ea8c h1:ncq/mPwQF4JjgDlrVEn3C11VoGHZN7m8qihwgMEtzYw=
 github.com/power-devops/perfstat v0.0.0-20210106213030-5aafc221ea8c/go.mod h1:OmDBASR4679mdNQnz2pUhc2G8CO2JrUAVFDRBDP/hJE=
 github.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=
@@ -17,19 +33,49 @@ github.com/spf13/cobra v1.10.1 h1:lJeBwCfmrnXthfAupyUTzJ/J4Nc1RsHC/mSRU2dll/s=
 github.com/spf13/cobra v1.10.1/go.mod h1:7SmJGaTHFVBY0jW4NXGluQoLvhqFQM+6XSKD+P4XaB0=
 github.com/spf13/pflag v1.0.9 h1:9exaQaMOCwffKiiiYk6/BndUBv+iRViNW+4lEMi0PvY=
 github.com/spf13/pflag v1.0.9/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=
+github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
+github.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
 github.com/tklauser/go-sysconf v0.3.12 h1:0QaGUFOdQaIVdPgfITYzaTegZvdCjmYO52cSFAEVmqU=
 github.com/tklauser/go-sysconf v0.3.12/go.mod h1:Ho14jnntGE1fpdOqQEEaiKRpvIavV0hSfmBq8nJbHYI=
 github.com/tklauser/numcpus v0.6.1 h1:ng9scYS7az0Bk4OZLvrNXNSAO2Pxr1XXRAPyjhIx+Fk=
 github.com/tklauser/numcpus v0.6.1/go.mod h1:1XfjsgE2zo8GVw7POkMbHENHzVg3GzmoZ9fESEdAacY=
+github.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=
 github.com/yusufpapurcu/wmi v1.2.4 h1:zFUKzehAFReQwLys1b/iSMl+JQGSCSjtVqQn9bBrPo0=
 github.com/yusufpapurcu/wmi v1.2.4/go.mod h1:SBZ9tNy3G9/m5Oi98Zks0QjeHVDvuK0qfxQmPyzfmi0=
+golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
+golang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=
+golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=
+golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
+golang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
+golang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=
+golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
+golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
+golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
+golang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
 golang.org/x/sys v0.0.0-20190916202348-b4ddaad3f8a3/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
+golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
 golang.org/x/sys v0.0.0-20201204225414-ed752295db88/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
+golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
+golang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
+golang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/sys v0.8.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/sys v0.11.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/sys v0.20.0 h1:Od9JTbYCk261bKm4M/mw7AklTlFYIa0bIp9BgSm1S8Y=
 golang.org/x/sys v0.20.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
+golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
+golang.org/x/term v0.0.0-20210927222741-03fcf44c2211 h1:JGgROgKl9N8DuW20oFS5gxc+lE67/N3FcwmBPMe7ArY=
+golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=
+golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
+golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
+golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=
+golang.org/x/text v0.4.0 h1:BrVqGRd7+k1DiOgtnFvAkoQEWQvBc25ouMJM6429SFg=
+golang.org/x/text v0.4.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=
+golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
+golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
+golang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=
+golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
 golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
 gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
+gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
 gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
 gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
diff --git a/internal/nexus/client.go b/internal/nexus/client.go
index dbd6a13..37b6d6a 100644
--- a/internal/nexus/client.go
+++ b/internal/nexus/client.go
@@ -2,10 +2,10 @@
 package nexus
 
 import (
+	"embed"
 	"encoding/json"
 	"fmt"
 	"net/http"
-	"os"
 	"time"
 )
 
@@ -62,32 +62,26 @@ func (c *Client) ListNodes() ([]Node, error) {
 // --- MOCK IMPLEMENTATION ---
 var mockJobs []Job
 var jobIndex = 0
-var jobsLoaded = false
 
-func loadMockJobs() error {
-	if jobsLoaded {
-		return nil
-	}
-	fmt.Println("[DEBUG] NexusClient: Loading mock jobs from mock_jobs.json...")
-	file, err := os.ReadFile("mock_jobs.json")
-	if err != nil {
-		return fmt.Errorf("could not read mock_jobs.json: %w", err)
-	}
-	err = json.Unmarshal(file, &mockJobs)
-	if err != nil {
-		return fmt.Errorf("could not parse mock_jobs.json: %w", err)
+//go:embed mock_jobs.json
+var MockJobsFS embed.FS
+
+func LoadMockJobs() {
+	if mockJobs == nil { // Only load once
+		fmt.Println("[DEBUG] NexusClient: Loading mock jobs from mock_jobs.json...")
+		data, err := MockJobsFS.ReadFile("mock_jobs.json")
+		if err != nil {
+			panic(fmt.Sprintf("failed to read embedded mock_jobs.json: %v", err))
+		}
+		if err := json.Unmarshal(data, &mockJobs); err != nil {
+			panic(fmt.Sprintf("failed to parse mock_jobs.json: %v", err))
+		}
+		fmt.Printf("[DEBUG] NexusClient: Loaded %d mock jobs.\n", len(mockJobs))
 	}
-	jobsLoaded = true
-	fmt.Printf("[DEBUG] NexusClient: Loaded %d mock jobs.\n", len(mockJobs))
-	return nil
 }
 
 func (c *Client) GetNextJob() (*Job, error) {
-	if err := loadMockJobs(); err != nil {
-		// On failure, return the error and stop.
-		return nil, err
-	}
-
+	LoadMockJobs() // Ensure jobs are loaded
 	if jobIndex < len(mockJobs) {
 		job := mockJobs[jobIndex]
 		jobIndex++
diff --git a/mock_jobs.json b/mock_jobs.json
deleted file mode 100644
index 5314b86..0000000
--- a/mock_jobs.json
+++ /dev/null
@@ -1,50 +0,0 @@
-[
-  {
-    "id": "job-download-llama2",
-    "type": "DOWNLOAD_MODEL",
-    "payload": {
-      "repo_url": "https://huggingface.co/TheBloke/Llama-2-7B-Chat-GGUF",
-      "file_name": "llama-2-7b-chat.Q4_K_M.gguf",
-      "model_type": "llamacpp"
-    }
-  },
-  {
-    "id": "job-infer-llama2",
-    "type": "LLAMACPP_INFERENCE",
-    "payload": {
-      "model_file": "llama-2-7b-chat.Q4_K_M.gguf",
-      "prompt": "In one sentence, what is the purpose of a sovereign compute fabric?"
-    }
-  },
-  {
-    "id": "job-pull-ollama-llama2",
-    "type": "OLLAMA_PULL",
-    "payload": {
-      "model": "llama2"
-    }
-  },
-  {
-    "id": "job-infer-ollama-llama2",
-    "type": "OLLAMA_INFERENCE",
-    "payload": {
-      "model": "llama2",
-      "prompt": "In one sentence, what is the purpose of a sovereign compute fabric?"
-    }
-  },
-  {
-    "id": "job-llamacpp-poem",
-    "type": "LLAMACPP_INFERENCE",
-    "payload": {
-      "model_file": "llama-2-7b-chat.Q4_K_M.gguf",
-      "prompt": "Write a short poem about servers and code."
-    }
-  },
-  {
-    "id": "job-infer-vllm-qwen3",
-    "type": "VLLM_INFERENCE",
-    "payload": {
-      "model": "Qwen/Qwen3-0.6B",
-      "prompt": "Explain the concept of a 'sovereign compute fabric' in three bullet points."
-    }
-  }
-]
\ No newline at end of file
